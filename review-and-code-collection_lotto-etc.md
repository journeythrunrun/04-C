> Refresh and review C language basics

> 책
  >> 서현우. *혼자 공부하는 C언어*. 개정판, 한빛미디어, 2023.

```
> P.S. 다른 문서나 파일에 내용이 있어서(워드, 코랩, VS) 수정 예정. 깃허브에 업데이트는 상황 상 챕터 순서대로는 안할듯.
> #~는 나중에 추가 수정 예정
```

# 목차
```
```


## 텍스트
### Ch 11 문자 ( 지식 정리 목적 상 뒷 챕터 내용을 이 부분에 적기도 했음 )
- 문자를 int형에 저장할 수 있고, (아마 8bit 이하)숫자를 char형에 저장할 수 있음. 출력도 %c, %d 다 가능.
  > %d 등의 변환 문자는 코드화된 문자열을 숫자로 변환하는 방법을 scanf 함수에 알려주는 역할을 함. 

- 디버깅
  + scanf 때든 실행이랑 약간 다르기도 한가봄. 실행 땐 Ctrl+Z + 엔터 세 번 누르면 나가졌는데(%s scanf), 디버깅땐 Ctrl + Z + 엔터 두 번씩 해야 다음 거 입력가능하고 그걸 세 번 해도 안나가짐

- scanf <- 변수의 주소
  + 반환
    + 성공 ( 입력에 성공한 데이터의 개수. [입력 성공한 변수의 개수인듯])
    + Ctrl+Z [ / OS에 따라서 키보드 입력 방식이 달라질 수 있는데 Ctrl Z , Enter, Ctrl Z 를 입력해야하는 경우도 있음(윈도우 10,). scanf라 엔터까지 입력해야함. / 유닉스나 리눅스에서는 Ctrl D ] (EOF=-1)

  + %s : 화이트 스페이스 이전까지만 가져와서 저장. (문자열)널문자 자동 추가해서 저장. "엔터"는 "버퍼"에 들어가있음
    > 화이트스페이스를 기준으로 쪼개서 받음
    > 화이트스페이스는 %c로 받기
    
  + %c : %s는 알아서 화이트스페이스 무시했지만, %c는 띄어쓰기 해줘야 무시함.
    > 이때까진 %c를 개수에 맞게 썼어서 버퍼의 남은 엔터를 안써서 안쓰였던 것 뿐이었음. 다음 scanf가 화이트스페이스를 먹지 않게 하기 위해 %c 앞/옆에 화이트스페이스를 넣어줬던 것임

  + 내부적 작동의 시간적 흐름
    > (최초 scanf 함수가 호출될 때 키보드로) 문자열을 입력하면 엔터를 누르면 엔터까지 버퍼(((저 케이스인지))숫자도 문자열의 값으로 저장. %d 사용 시 연산 가능한 숫자로 변환되어 저장됨. )에 저장한 후
    > -> 호출한 %c 만큼 가져감. 두 번째 scanf 함수 호출부터는 버퍼에 남아있는 문자열에서 차례로 다음 문자를 가져오므로 결국 새로운 키보드 입력이 필요없는 경우가 있음. ((첫 scanf 때 첫 scanf가 원하는 개수보다 많은 문자열을 입력했을 때 등))
    > ((입력하라고 다시 뜨는 경우는 버퍼에 저장된 데이터가 모두 가져가진 때임. ))

  > scanf에서 버퍼 사용해서 좋은 점
    >> (1) 데이터를 안정적으로 입력 받을 수 있음(다른 프로그램하고 있을 때도. )
    >> (2) scanf는 키보드가 아닌 버퍼에서 직접적으로 입력을 받음. 입력장치가 바뀌더라도 함수 수정 없이 사용 가능. 버퍼와 입력장치 연결은 OS가 담당함.

- 엔터도 입력 받는 방법
  + m1) int a = getchar();
  + m2) while( returned != EOF ), scanf, %c
    + 반복문이라 필요한 종료조건을 위해 리턴값을 활용
      > 예전엔 엔터로 구분해서 받았음
      
    > Ex. (아래코드) A엔터 -> 6510 출력 (버퍼에 남아있던 엔터가 다음 while 회전에서 출력됨.) ->스페이스cat엔터->32999711610
      ```C
      int ret; 
      char ch;
      while (1) {
        ret = scanf("%c", &ch);
        if (ret == -1)break; 
        printf("%d", ch);
      }
      ```

  + Ex. &lotto_nums[i]  [ scanf("%d", &lotto_nums[i]); ] // - 인덱스 있기에 값이라 배열이든 포인터든 & 붙여야 주소임.
  
  + 같은 변수에 scanf 두 번 받을 시 : 해당 부분 덮어쓰기됨.

  + "문자 입출력" 땐 이것이 아닌 "문자 전용 함수"가 더 효율적.
    > scanf, printf는 char형 뿐 아니라 숫자도 다뤄서 함수 크기가 큼. 


- 입력함수들은 버퍼 공유함
  > scanf에 의한 엔터가 버퍼에 남아있는 것 주의
    > 그 후 다른 방법으로 받았다가 엔터 가져오는 것 조심
  
  + 버퍼에 남은 내용 지우는 법
    + M5. getchar(); : 문자 하나  |  & while ( getchar() !='\n'  ) : 전부
    + M1. scanf("%*c"); : 문자 하나 읽어오고 저장안함[*] 
    + M3. fgetc(stdin); : 문자 하나 버림

> 10=='\n' : True

### 문자열 단어, 한 줄 받기 with 문자 입출력 방법들 
> 여기서부터 ch 12까지 말 가다듬기 예정 #~

- M1. scanf & %s : 화이트 스페이스로 변수 자동 분리 가능
  + 장점 : 한줄 한 꺼번에 받으면, 원하는 데이터에 따라 입력 받은 걸 쪼개야하는 경우가 있는데 그거 간략화

  + scanf가 엔터 남긴다 쳐도 다시 또 scanf로 받으면 엔터 버려짐

- M2. fscanf / fprintf  :  파일 지정 가능
  + res = fscanf ( ifp, "%s%d", name, &numb);
    + 반환 : 성공(), 실패(파일의 데이터를 모두 읽으면 EOF)
    + 파일에 저장된 문자열을 '숫자로 변환'해서 입력할 때
    
  + / fprintf ( ofp, "%s%d", name, total ); // %s는 주소인데 배열이라 이름이 주소고, total은 scanf아니고 출력함수랑 쓰이는 거라 주소 아니어도 됨. 
    + 반환 : 성공(출력한 문자의 byte 수), 실패(오류_음수)

    + 정수나 실'수'를 쉽게 파일에 출력할 때
    > 문자열로 자동변환해서 출력


- M3. fgets( str, sizeof(str), stdin); : 화이트스페이스 세 개 다 저장 가능
  + 개행 문자가 나올 때까지 문자열을 입력. 
  + 반환 : 성공(입력한 배열의 주소. str), 실패(_더이상 읽을 데이터가 없음NULL)
  + (1) 화이트스페이스 세 개 다 저장함. & (개행 문자 기준으로 말고 설정한 크기까지 읽음)
    + 마지막 엔터 지우려면 : str [ strlen( str )_[엔터포함 개수] -1  = '\0' // 엔터위치의 인덱스

  + (2) 배열 크기를 확인함. 넘게 입력해도 최대 배열의 크기까지만 문자열을 저장함.

  > stdin : 건네면 파일 포인터로 줄 수 있음 , 키보드와 연결된 표준 입력 버퍼를 사용하라. fgets은 입력 버퍼를 선택할 수 있음

  + f없는 것보다 fgets fputs가 나음. 메모리 침범 가능성 제거.
    > 키보드와 모니터로 문자열을 입출력할 때 쉽게 gets와 puts 함수를 사용할 수 있긴함.

  + 초기값 있으면, 수정한 부분만 덮어쓰기됨. 엔터랑 널문자까지 저장함.


  + / fputs( str, fp ) ; 
    + 자동 엔터 없음
    + 성공( 시스템에 따라 0 또는 출력한 문자의 수), 실패(EOF)

- M3.2 : int a = fgetc(stdin) ;  / fputc( a, stdout) ;
  + 별도로 인수를 주는 것 외에는 getchar / putchar 함수와 기능 같음.
  +  호출할 때 추가적인 인수 필요한데 fgetc는 stdin[standard input. 표준 입력장치인 키보드와 연결된 버퍼의 이름.]을 주고 / fputc는 stdout[출력 버퍼 이름]을 줌. 

  + [파일에 사용] int ch = fgetc( fp );  // 스트림/버퍼가 fp인 걸로 이름만 다른듯
    > 입출력 함수가 '같은 파일 포인터'를 사용하면 스트림 파일의 버퍼를 공유함.
    + 반환 : 성공(입력한 문자), 오류나 데이터 다 읽은 경우 (EOF=-1)
      + -1보다 EOF 사용. 시스템에 따라 EOF 값을 뭘로 정의했는지 다를 수 있음.
      > 파일의 크기와 현재까지 읽어 들인 데이터의 크기를 비교해서 판단함

  + / fputc(str[i], fp);
    + 반환 :  성공(출력한 문자. 음수가 아닌값), 실패(EOF)

- M4. gets(str) ;
  + (1) "공백, 탭 포함"한 문자열 한 줄 받을 수 있음.
  > 중간의 공백, 탭 문자를 포함해 문자열 한 줄을 입력함

  + (2) '버퍼'에는 '엔터'가 마지막에 들어가지만, '변수'에 저장될 땐 '0'(NULL)으로 바뀜
  + scanf는 입력한 문자열이 없으면 엔터를 눌러도 입력을 기다림. gets는 엔터만 눌러도 끝남[ 0 1개 저장]

  > Ex. 12 ab   e=>49 50 32 97 98 9 101 0 -52

- M5. [문자전용함수] getchar & putchar 
  + int ch= getchar() ;  // 무조건 앞 '첫글자(한글자)'만 받음. 52입력하면 5. -> 여러 갠 반복문 써야함.
    > 알파벳이든 숫자든 다 아스키 값으로 저장
    + 얘도 버퍼 사용.
    + 문자 입력을 끝내기 위해 Ctrl+Z 누르면 EOF -1반환함.
    + 저 예시 말고도 반환형을 int형으로 하는 게 좋음. char형에 저장하면 1바이트라 255랑 -1을 숫자로 구분할 수가 없게됨.
      + 키보드로 입력가능한 건 모두 0~127아스키코드라 -1과 안 겹쳐서 상관없는데, '파일'을 읽을 땐 반환하는 값이 255일 수 있음. 1byte로는 -1과 구분불가. (-1 은 11111111 11111111 11111111 "1111111", 255는 00000000 00000000 00000000 11111111인데 뒤 1byte만 이용하면 구분 불가능함. )

    + 따라서 문자를 반복 입력하는 경우, int형 변수에 저장 후, -1과 비교->-1이 아니면 별도의 char형 변수에 옮겨 사용이 좋음.
    +  화이트스페이스도 입력

  + putchar(ch);
    + 출력 과정에서 에러 나면 -1반환.

> (아마 특정 케이스 문맥에서 설명하던 부분일 수 있음) 버퍼에 저장되는 데이터의 끝에는 항상 개행 문자가 있음


- M6. fwrite ( &num, sizeof(num),1, bfpㅁ) ;  // 데이터 타입의 사이즈, 개수(배열이라면 요소수). 어차피 곱해서 사용하는 값이라 실제랑 달라도 되긴 함.
  + 문자열(아스키코드)로 저장 안하고, 변환 과정 없이 메모리에 있는 데이터를 그대로 파일에 저장. (어떤 예시에서) 바이너리 파일이고 메모장과 같은 텍스트 파일 편집기로 보거나 편집 불가 => fread, fwrite는 대용량의 데이터 입출력 때 유용함. 데이터의 크기 지정 가능
  + 'b'
  + 반환 : 성공(출력한 데이터 수)
  + 주소로 가서 크기와 개수를 곱한 byte 수를 읽어 파일 포인터의 파일에 출력함
  > '출력한' 데이터 크기 찾기 : numb = fwrite(ary, 1, sizeof(ary),bfp); // sizeof는 전체 데이터 크기

- fflush(stdout);
  > 575p

  + 출력버퍼의 내용을 지울 때 사용
    > 출력할 때 사용하며 스트림 버퍼의 내용을 즉시 장치로 기록함.
  > 파일포인터를 인수로 주면 파일 포인터와 연결된 스트림 파일의 버퍼를 비움
- Quiz. 파일 입출력 함수 fgetc / fputc / fgets / fputs / fscanf / fprintf 중 반환값의 형태가 다른 함수는? 
  + fgets는 char *형이고 나머지는 int 형임 


    
## Ch 12 문자열
- 컴파일 과정에서 문자열을 char 배열 형태로 따로 보관하고 "문자열 상수가 있던 곳"에는 "배열의 위치 값"을 사용함 -> 포인터 연산 수행 가능
  + 주소로 접근해서 문자열을 바꾸면 안됨. Ex. *"apple"='t'; 
    > 문자열을 주소로 바꾸면 포인터 연산을 통해 문자열의 시작 위치부터 길이 제한 없이 사용할 수 있음.
    > 컴파일은 되지만, 실행할 때 운영체제에 의해 강제 종료될 가능성이 있음. 호환성을 위해 사용 말기.
    > OS는 문자열 상수를 읽기 전용 메모리 영역에 저장함.


  + +1했더니 아예 배열? 변수? 주소 뛰어넘던 것도 있지 않나. 헷갈리지 않게 비교 확인 #~ 
  + 주소+1 ~  
  + %p" , "apple"+1  //  apple로 했을 때 나온 주소 +1되네 // char형이라 a'p'ple의 주소라 +1됨.
  + %c", *"apple"  // a
  + %c", *("apple" +1) // p // 0번째 주소 +1의 값.
  + %c", "apple"[2] // p


- 같은 문자열 상수 여러 번 : (컴파일러 최적화기능이라 마다 다를 수 있음)  하나의 주소를 공유
- #define ㅁ ㅇ


- puts_마지막에 엔터해줌
  + 정상 출력 시 0반환, 실패 시 -1 반환

- (1) strcpy( ㅁ,  ㅇ); // 문자열 복사
  + memcpy와 달리 0나오면 멈춤. strcpy대신 memcpy사용 가능
  + #include <string.h>
  + 널문자는 저장되지 않기에 필요하면 별도로 저장해야함.
  + str"n"cpy (ㅁ, ㅇ, 5); 
  
- (2) strcat ( ㅁ, ㅇ);
  + ㅁ의 0을 찾은 후 concatenate마냥 +
    + 널 문자가 초기화돼있지 않으면 쓰레기 값의 중간부터 붙여 넣을 가능성이 큼.
  + 널문자도 저장함
  + 저장할 공간이 부족한 경우 할당하지 않은 다른 메모리 영역 침범 가능 (이 문제는 컴파일에서 발견 못하고 실행 후 발생해버림)

  + str"n"cat


- (3) strcmp
  + 아스키 값으로 비교
  + str"n"cmp
- %6d : 자리수 달라도 깔끔하게 출력. 오른쪽 몰기.

### Ch 13 변수의 영역과 데이터 공유
- 최대한 지역 변수 사용하기
  > (auto) int a =3.

  + 스택 영역에 저장
  + 장점
    + 메모리 효율 _ 지역 변수 할당 영역 반환되면 저장 공간 자동 회수 #~ <-> 동적 할당 포함 영역이 닫혔을 때
    + 디버깅에 유리.
      > a의 값이 이상할 경우 그 영역만 보면 됨
      > 지역 변수가 할당된 저장 공간은 자동으로 초기화되지 않으므로 쓰레기 값이 사용되지 않도록 주의

- { } 블록 내부도 고유한 지역변수 영역임
  + 차이점 : 함수 속 블록이라, 블록 밖 같은 함수에서 선언된 것은 블록에서 사용 가능(함수 간 과는 다름).

  + 블록 중첩 / 사용 가능한 변수가 둘 이상이면 가장 가까운 블록에 선언된 변수 사용
    + 내부 블록에서 재선언시, 재정의가 아니라, 새 지역변수인 거라 첫 변수에 반영 안됨.

  > 함수처럼 그 영역 안에서 선언된 것은 그 안에서의 지역변수임

- (2) 전역 변수
  + 자동 0 초기화
  + 단점
    + 이름을 바꾸면, 모든 함수에서 그 이름을 찾아서 수정해야함
    + 값이 잘못된 경우 접근 가능한 모든 함수를 의심해야함
    > 코드 블록 내에 동일한 이름의 지역 변수를 선언하면 거기서는 전역 변수 사용 어차피 불가
  
  + 선호 케이스
    + 많은 함수에서 수시로 데이터를 공유하는 경우에만 제한적으로 사용하는 것이 좋다.

   + 교수님은 헷갈리지 않게 전역변수는 _로 시작하게 함

- (3) static variable [정적 지역 변수] (하나의 파일 내부)
  + 0 자동 초기화
  + 자신의 함수가 반환돼도 그 저장공간을 프로그램이 실행되는 동안 계속 유지. 사용은 그 함수에서만 사용가능.
    > 하나의 함수가 여러 번 호출되는 경우 같은 변수를 공유하는 것이 가능
  > 저장 공간이 메모리에 존재하는 기간이 다름
  + 데이터 영역에 저장 (전역 변수도 그럼)

- (4) register variable
  + 차이 : CPU 안에 있는 레지스터 공간에 저장
    > 실행시간 단축
  + 전역변수는 불가
  + 주소를 구할 수 없음
  + 최종 사용 가능은 컴파일러가 결정


- 값 복사 전달 VS 주소 전달
  +  꼭 필요한 경우가 아니면 값 복사 전달[근데 유용해서 주소전달 많이들 함]. 절대 바꾸면 안 되는 데이터를 다룰 때 주소 전달했다가 문제 생길 수 있음.

- 주소 값 반환
  + int * cal(void){ static int res; return &res; }  // <-> 포인터 이름 #~
  + (정적변수가 아닌 완전) 지역 변수의 주소를 반환해서는 안됨
    > 해당 공간이 사라지기 때문임.
    > 동적 할당 메모리 주소는 ㄱㅊ함
    
- 퀴즈
  + 다음은 키보드로부터 정수를 입력받은 후에 값이 저장된 변수의 주소를 반환하는 함수입니다. 구현에 문제가 있다면 있는 부분을 찾고 이유 적기
  ```C
  int *get(void){
    int n; scanf ("%d", &n); return &n;
  }

  + static
  ```

> 코드 바로 공유하기 편한 곳
  + https://codeshare.io/

### Ch 17 사용자 정의 자료형
#### 구조체
> 다양한 자료형을 저장할 때 유용함

- 구조체 선언
  + ``` 
    // M3. typedef 형 재정의를 통해  예약어 없애기=typedef ㅇ_"struct student"_[구조체 이름] ㅁ_Student;
    // M2. 기본 "struct student" { }  ((person1 = {1,'a'})) ; 
    // M1. 최대압축 "typedef" "struct" {} "studdent2_t" ;

    "struct student" person1 ; [예약어 구조체이름 변수명]/ student2_t person2 ;

    person1.num=2 ;
    ```
  + 함수 밖에서 구조체를 선언하면 선언되는 변수가 전역 변수이므로 디폴트 0으로 초기화됨.

  + 다른 구조체를 멤버로 사용 가능
    + 멤버 선언 : struct student s; 
    + 사용 : person1.s.age=
  + 포인터 멤버 : Ex. 동적할당 예정

- 구조체의 주소 = &person1. 이름 아님.

- 구조체 초기화, 선언 && 초기화
  + struct student person1 = {1, 'a'}, person2 ={2, 'b'};
    > 중괄호, 순서에 맞게 나열


- 자료형이 같은 구조체 변수는 대입 연산 가능
  > person1=person2

- 구조체 & 함수
  + 입출력이 구조체일 때 "struct student" exchange (struct student a );

- sizeof ( struct student ) // 예약어 구조체 이름

- 멤버 간 데이터 형식의 크기가 다를 때, 가장 큰 크기가 메모리를 할당하는 기준 단위가 됨.
  + 멤버의 순서에 따라 구조체 크기가 달라질 수 있음. 
    + 1 byte, 2(이전 변수에 1 패딩), 1, 4(이전 변수에 3패딩), 8(이전 변수에 4패딩), 1(남은 7바이트 패딩됨)

  > 멤버 사이 패딩 바이트를 넣음
  > 패딩 바이트 안 넣는 법 : #pragma pack(1); ( 보통 include 다음에 넣음 )
    > 데이터를 읽고 쓰는 시간은 증가함. 메모리는 최소화. 


- 함수 넣는 거 인수 받는 거 매개변수인듯

- 구조체 포인터
  + "struct student" * ps = & person1 
    > 변수 형식 이름만 다르고 똑같음
  
  + M1. ps -> name 
  + M2. (사용 시 괄호) (*ps).name
    +  .이 *보다 우선 순위 높음

- 구조체 변수 자체가 하나의 큰 변수임. -> 구조체 배열 가능.
  + 초기화
    + struct student people[100] = { {1,2},{3,4} }

  + (para+i)->name / para[i].name / ( *(para+i)).name


- 자기 참조 구조체
  + 멤버 변수가 자신의 구조체을 가리킴 
  + 연결 리스트 구현[링크드 리스트]
    + 첫 번째 변수의 위치만 알면 다른 건 따라가서 모두 사용할 수 있음.

  
  + ```C // 아래 예시는 각 객체가 이름을 가지고 있는데, 어차피 연결리스트로 연결하면 접근할 수 있어서인지, 예제 2는 tail->next에 동적공간 할당만해나감 
    //...
    struct student * next ;
    //...

    struct student person1 ={1,2}, person2 = {3,4}, person3={5,6};
    struct student * head = & person1, *current; 헤드 포인터 초기화
    // head는 person1 가리킴

    person1.next=&person2; // person1의 포인터인 멤버가 person2를 가리킴
    person2.next=&person3; 

    // head->name 출력
    // head->next->name 출력
    
    current = head;
    
    while (curret!=NULL){ // 원형 연결 리스트 아니기에 마지막 놈은 next가 0으로 초기화돼있음.
      //current->name 출력
      current = current-> next; // next가 다음 person가르키게 해뒀었음.
    }
    ```

    + head로 3번째 꺼 사용하려면 : head->next->next->name

    + 길면 계속 next 번거로우므로 움직이는 current 사용. 이 연결 리스트는 이전 꺼로 돌아가는 거 없으므로 첫 주소 잃어버리면 안돼서 head고정.

#### 공용체
- 모든 멤버가 하나의 저장 공간을 같이 사용함
  + 그래서 다른 멤버 값 바꿨는데 다른 멤버 값이 바뀌기도 함.
    > 항상 각 멤버의 값을 확인해야함


- 선언
  + 예약어가 union인 거 빼고는 구조체와 같음

- 초기화
  + 중괄호를 사용해서 첫 멤버만 초기화. 다른 멤버를 초기화할 땐 접근 연산자로 멤버 직접 지정.
    ```C
    "union student" person1 = {315}; 
    union student person2= { .grade = 97.7 }
    ```


- 공용체 변수의 크기
  + 멤버 중 크기가 가장 큰 멤버의 크기.를 다른 멤버들도 공유하며 씀.


- 열거형
  + 변수에 저장할 수 있는 정수 값을 기호로 정의해서 나열함 
  + "enum season" {SPRING=5, SUMMER, FALL=10, WINTER};// 디폴트 0,1,2,3 // 저 케이스엔 그 다음 숫자인 6, 11
    + 해당 열거형에 없는 값도 가질 수 있음 (++) 
  > 숫자 대신 이름 써서 읽기 쉬운 코드화
  + enum season first24=SPRING;
  
  
  -  head(포인터임) = tail = (Train *) malloc(sizeof(Train)); // 각각 생성 아니고, 같은 거 가르키는 거임. 포인터잖슴.


## ch 18 파일 입출력
- 파일의 개방과 폐쇄
  + (1) FILE *fp ;
    > 스트림 파일 : 파일 구조체 변수((버퍼의 입출력 위치 지시자), (스트림) 버퍼,  등
      > 문자 배열 형태의 버퍼와 FILE 구조체(버퍼의 메모리 위치, 크기, 버퍼에서 데이터를 읽거나 쓸 때 그 위치, )를 가지고 있음. 스트림 파일이 사용하는 구조체 이름이 FILE임.

      > 장점
        + 입출력 효율 높이고, 입출력 장치가 바뀌어도 장치로부터 독립된 프로그래밍 가능
         > 스트림 파일과 입출력 장치의 연결은 HW의 특성에 따라 OS가 담당
        + 버퍼에 출력 데이터를 모아 한 번에 장치로 보내면, 장치가 데이터를 기록하는 시간에 프로그램이 다시 버퍼를 채울 수 있음.


  + (2) fp = fopen("a.txt  or c:\\source\\a.txt"", "r");
    > fopen  : (1) 실제 파일이 있는 장치(하드디스크 등)와 연결되는 스트림 파일을 메모리에 만듬. (2) 스트림 파일에 접근할 수 있도록 파일 포인터를 반환함.
    
    + 성공(FILE 포인터), 실패(NULL=0)
    + (2.2) 'w' : 파일의 내용을 모두 지우고 쓰기 위해 개방 | 파일이 없으면 새로운 파일 생성
    + (2.3) 'a' : 파일의 끝에 추가하기 위해 개방 | 파일이 없으면 새로운 파일 생성
    + (2.4) 'rb+' : +_읽고 쓰기 전부. 나머지인 '쓰기'도 추가
      + +에선 입/출력 스트림파일 따로 안 쓰나 봄. 설명 상 지칭만 구별되게 한 걸 수도. 애초에 fp가 한 개이고 입력/출력 시 똑같이 선언하긴 함.

      > 버퍼에 데이터가 남아있으면 입/출력 꼬임. fprintf는 스트림파일의 버퍼에 데이터를 출력해놓음
      
      
      + 파일 다 읽었는지 확인 if ( feof(fp) ) break ;  
        > 파일 다 읽었으면 읽는 반복문 탈출
        > 입력 함수 후 확인. 스트림 파일의 데이터를 모두 읽었는지 확인.

        + 반환 : 파일의 끝(0이 아닌 값), 끝이 아니면(0)

      + fseek : 입/출력 전환 때 사용. 파일의 끝까지 모두 읽고 나서 쓰기로 바꾸는 경우는 안 써도 됨.
        + Ex. feek(fp, 0_만큼 위치지시자를 옮김,SEEK_SET[매크로명]_을 기준으로 옮김);   == rewind(fp); : 버퍼 비우기
    
          > 버퍼의 위치 지시자를 맨 처음으로 이동하며 그 전에 버퍼의 내용을 하드디스크로 출력함(??)

        + (1) SEEK_SET : 기준 위치_파일의 처음, 오프셋값_양수만 가능
        + (2) SEEK_CUR : 기준 위치_파일의 현재 위치, 오프셋값_양수 음수 가능
        + (3) SEEK_END : 기준 위치_파일의 끝, 오프셋값_음수만 가능

        + 반환 : 성공(0이 아닌 값), 실패(0)
    
      + ```C
        while(1){
          scanf("%s",str); // 입력 받
          if (strcmp(str,"end")==0) break; // -  조건 strcmp(str,"end") == 0 // end 입력 시 종료.
          
          else if(strcmp(str, "list){
            fseek(fp,0,SEEK_SET); // 전환할 거라 비우기.
            while(1){
              fgets(str, sizeof(str),fp); // 읽기
              if (feof(fp)) break; // 파일 내용 모두 읽으면 종료
              printf("%s", str);
            }
          }
          else
          fprintf(fp, "%s\n", str); // 파일에 쓰기
        }
        ```
    + (2.5) 'w+' 데이터를 읽다가 중간에 다시 쓰는 경우 설정한 위치부터 내용을 덮어씀.


  + (2-2) if (fp==NULL) { return 1 ;}
    + NULL이 반환 되면 간접 참조해 사용할 수 없으므로 체크
    > 'w'나 'a'도 개방 가능 파일 수를 넘거나 메모리에 문제가 생길 수 있으므로 체크

  + (3) fclose(fp);
    + 성공(0), 실패(EOF=-1) // stdio h에 정의됨.
    > 개방한 스트림 파일을 메모리에서 제거

  
  
  + 현재 작업 디렉터리 = 실행 파일이 있는 곳 / VS 같은 통합 개발 환경에서는 프로젝트 폴더
  + \ : 제어 문자의 시작

  + 상대 경로  ..사용 가능
    > "..\\
    
> stdio.h에서 NULL을 0으로 쓸 수 있게 정의 돼있음



- 파일 내용 가져와서 출력
  + ```C
    ...
    while(1) {
      ch = fgetc(fp);
      // fgetc 사용 이유 (1)  엔터도 저장해야하므로.
      // (2) 파일의 데이터 다 읽으면 EOF 반환
      
      if (ch ==EOF){ // (1.2)
        break;
      }
      putchar(ch);
    }
    ```

- 파일로 문자 출력 fputc(str[i], fp);
  > 한 문자씩 '버퍼'에 출력. 버퍼는 디스크에 한꺼번에 보냄(시스템에 따라 차이가 있을 수 있음. 버퍼 모두 채워졌을 때/ 개행 문자를 출력할 때 / 새로운 입력을 수행하는 경우)

  + ```C
    int i=0;
    while( str[i]!='\0')
    {
      fputc( str[i]. fp );
      i++;
    }
    fputc('\n',fp);
    ```
    
- fflush
  + 버퍼의 데이터를 즉시 장치로 출력


- os에 따라 기본적으로 개방하는 스트림 파일의 수가 다를 수 있지만, 3개의 스트림 파일은 공통적으로 개방함.
  + [OS가 개방한 ((스트림))파일의 주소, 스트림 파일명] stdin_키보드 연결, stdout_모니터 연결, stderr(표준 에러 스트림)_모니터 연결
    > 표준 에러 스트림 : 출력 과정에서 발생하는 오류 메시지 등을 화면으로 확인 가능하도록 또 다른 출력 경로 제공
- ctrl Z하면 나오는 ^z는 EOF 문자임. 유닉스나 리눅스에서는 Ctrl D

- f가 들어가는 fgetc, fputc 함수 등이 파일포인터를 인수로 받는 함수인듯


- 텍스트 파일(아스키코드 값. 메모장에서 확인 가능 | 't' ) VS 바이너리 파일( 그 이외.  그림파일 및 그림판 등 | 'b' )
  + rb wb ab. 디폴트는 텍스트 파일


- [텍스트 모드로 개방된 파일]. ( <-> 바이너리 모드로 개방된 파일은 파일의 내용을 있는 그대로 읽거나 씀 )
- [] 바이너리 파일로 쓴 것 {13, 10, 13, 13, 10, 26, 13, 10} 텍스트 파일로 읽기
  + 10 13 10 만 출력 됨. 바이너리 파일 자체는 10바이트의 크기를 가짐.
  > fgetc 함수는 리턴문자(\r)와 개행 문자를 연속으로 읽을 시 개행 문자 하나만 입력함
  > fgetc 함수는 ctrl Z에 대한 아스키 문자를 읽으면 파일의 끝으로 인식함. Ctrl Z의 아스키 문자를 읽고(26을 아스키로 받음) EOF를 반환해 입력 작업을 끝내게 됨

- [] 개행 문자 : 유닉스 시스템(\n), macOS(\r), 윈도우_화면(리턴문자+개행문자), 윈도우_프로그램(개행문자)

  + 따라서 유닉스 시스템에서는 파일의 형태를 텍스트 파일과 바이너리 파일로 구분하지 않고 모두 바이너리 파일 취급함
- [] 텍스트 파일에 출력하는 함수는 '개행 문자'를 출력할 때 '리턴 문자'를 추가해 2개의 문자를 파일에 출력함.


- 바이너리 파일이 이점 있음

#~
- mh.-nexus.de
- ren text.xlsx test.zip




## 코드
### Ch 10
- 로또 번호 생성 프로그램(도전 실전 예제, 로또 번호 생성 프로그램)
  ```C
  /* Ch 10_도전 실전 예제*/
  /* P.S. 코딩테스트를 위한 풀이라기보다 C언어 복습공부의 연장선인 빨리 풀기임.(문제도 코테용아님) 따라서 문제에서 말하는 조건과 실행결과를 만족하는 풀이이며, 문제에 언급되지 않은 예외케이스를 시간들여 전부 다루진 않음.*/
  #define _CRT_SECURE_NO_WARNINGS
  #include <stdio.h>
  //#include <string.h>
  void input_nums(int* lotto_nums) {
  	int numbers[46] = { 0 };
  	// - 조건에 갖춰진 골격에 따라 문제를 푼다면, 
  	//   + m1) 딕셔너리 유사 풀이는 매개변수를 더 건네야하는데 못함 -> main 말고 입력 함수 내에서로 옮김  
  	// - 맞다 0 초기화는 한 방 가능
  	//for (int i = 1; i < 46; i++) {
  	//	numbers[i] = 0;//없음
  	//}
  
  	for (int i = 0; i < 6; i++) {
  		printf("input (one): ");
  		scanf("%d", &lotto_nums[i]); 
  
  		// m1
  		while (numbers[lotto_nums[i]] == 1) {// 이미 있음
  			printf("already exist\n");// 엔터 습관~
  			printf("input (one): ");
  			scanf("%d", &lotto_nums[i]);
  		}
  		numbers[lotto_nums[i]] = 1;
  
  		// m2) 변수로 중복있는지 체크	
  		//int exist = 1;
  		//while (exist==1) { // - 해설의 방법은 이 while을 안씀. 중복이 있을 시 i--를 해서 가장 바깥의 for이 끝나지 않게함((어차피 6개의 서로 다른 입력 받는 상황)). 그러면서 scanf 여러 곳에서 쓰지 않고 압축함.
  		//	exist = 0;
  		// 
  		//	for (int j = 0; j < i; j++) { //이전 인덱스 까지 보면 되니까 j<i
  		//		if (lotto_nums[i] == lotto_nums[j]) { 
  		//			exist = 1;
  		//			printf("already exist");
  		//			printf("input (one): ");
  		//			scanf("%d", &lotto_nums[i]); // - 인덱스 있기에 배열이든 포인터든 & 붙여야함. //이름이 주소인 거 맞는데, 인덱스붙인 건 이미 값임. 그래서 
  
  		//			break; 
  		//		}
  		//	}
  		//}
  	}
  }
  
  void print_nums(int* lottos_nums) {
  	printf("lotto numbers :");
  	for (int i = 0; i < 6; i++) {
  		printf(" %d", lottos_nums[i]);
  	}
  }
  
  int main(void) {
  	int lotto_nums[6];
  
  	input_nums(lotto_nums);
  	print_nums(lotto_nums);  
  	return 0;
  }

  ```

### Ch 11
-  ch 11-2 길이가 가장 긴 단어 찾기[도전 실전 예제]
  + ctrl Z 받기 / 엔터도 받기
    ```C
    #define _CRT_SECURE_NO_WARNINGS
    #include<stdio.h>
    // ch 11-2 길이가 가장 긴 단어 찾기[도전 실전 예제]
    // 처음에 시간 걸렸던 이유 : 윈도우는 scanf 탈출키 다름
    // ctrl Z 받아서 종료하는 예제
    int main(void) {
    	// 가장 긴 단어의 길이만 저장
    	int max = 0, count = 0;
    	int res;
    	int s; // 언제나 255와 -1을 구분하기 위해.
    	// - 엔터도 받는 법 
    	//   + m1) int a = getchar();
    	//   + %s는 엔터 못받음.
    	// 
    	//   + m2) char형 * scanf_%c
    	//   + (1) while scanf_"%c"로 입력받기
    	//   + (2) if returned=-1 . 계속 반복 & %c 라 %s가 자동으로 엔터때 종료된 것과 다른 방식으로 종료 지정해줘야함 
    	char test1[10];// 한글자 넘게 받으려면 배열.!
    	while (1) {
    		//// m1)
    		s = getchar(); // 글자
    		if (s == -1)
    			break;
    
    		//// m2) s 를 char형으로 바꿔야함
    		//res = scanf("%c", &s);  // scanf %c는 Ctrl+Z,엔터 세트를 두 번해야함. #~
    		//if (res == -1) {
    		//	break;
    		//}
    
    		// m_) // 이건 세 번이나 해야하네 // 디버깅하면 Ctrl Z 넣으면 엔터 두번 쳐야 입력되는 듯 & 반환값은 0 되고, 변수에 저장은 안돼서 이전값 그대로임.
    		//res=scanf("%s", &test1); 
    		//printf("%s\n", test1);
    		//if (res == -1)
    		//	break;
    
    
    		// m_no) // 이건 세 번이나 해야하네 // 디버깅하면 Ctrl Z 넣으면 엔터 두번 쳐야 입력되는 듯 & 반환값은 0 되고, 변수에 저장은 안돼서 이전값 그대로임.
    		//res=scanf("%s", &test1); 
    		//printf("%s\n", test1);
    		//if (res == -1)
    		//	break;
    		
    		if (s == '\n') { // 10 == '\n'
    			if (count > max) max = count ;
    			count = 0;
    		}
    		else 
    			count++;
    
    		// m_no) 
    		////if ( sizeof(s)/sizeof(char) > max){ //// count 대신 엔터 나왔을 때 길이 계산하는 방법. s를 %s로 받아주고 초기화해야함. 근데 %s는 탈출이 귀찮아짐
    		////	max = sizeof(s) / sizeof(char); 
    		////}
    
    	}
    	printf("%d", max);
    	return 0;
    }
    ```


### Ch 12
- 12-2 확인 문제 3번 (입력한 단어의 길이가 5자를 넘는 경우 6자리부터 *출력. 최대길이 15자)
  ```C
  // m2) 교수님 코드
  // result[80]={0}
  // int i = 0; 미리 있으면 for (; 가능
  // result라는 변수를 따로 만들어서 입력의 모든 길이를 돌며[내코드의 for을 for 밖 조건문 없이] result에 변화돼야하는 결과로 저장함.
  // 내 코드가 코드로선 복잡하고 a < 5인 케이스 반영하면 효율일 수도 있음
  // m1)
  #define _CRT_SECURE_NO_WARNINGS
  #include <stdio.h>
  #include<string.h> 
  
  int main( void){
    char a[16];
    printf("단어 입력 :");
    scanf("%s", a); // c, 엔터 저장돼도 안쓰임
  
    if (strlen(a) > 5) {
      printf("\n입력한 단어 : %s, 생략한 단어 : ");
      for (int i = 0; i < strlen(a); i++) {
        if (i<5)
          printf("%c", a[i]);
        else 
          printf("*");
      }
    }
    else 
      printf("\n입력한 단어 : %s, 생략한 단어 : %s", a, a);// [0:5]
  
    return 0;
  }
  ```

- ch 12 단어 정렬 프로그램[도전 실전 예제]
  ```C
  // m2) 교수님 코드
  // 1,2비교  1,3비교,   2,3비교  // 두 번의 비교로 첫 번 째에 가장 작은 거 찾음. 나머지인 2,3비교로 두 번째 작은 거 찾음.
  // ->9,5,x   ->9,5, 8/3    ->
  
  // m1) 코드론 조금 더 복잡 & 효율은 나을 수도 (물론 if문 내부 등이 복잡하진 않을 땐 큰 차이 없을듯. 간단하게 하는 swap이 그렇게 무거울 거 같지도 않고)
  #define _CRT_SECURE_NO_WARNINGS
  #include <stdio.h>
  #include<string.h> 
  
  void strswap(char* first, char* second) { //*
    char temp[80];
    strcpy(temp, first);
    strcpy(first, second);
    strcpy(second, temp);
  }
  int main(void) {
    char a[80], b[80], c[80];
    scanf("%s %s %s", a, b, c);
    if (strcmp(a, b) == 1) { // - abc순 배열은 작은 게 앞으로임!
      strswap(a, b); // 9, 5,  x
    }
    //printf("%s %s %s", a, b, c);
  
    if (strcmp(b, c) == 1) {// 9,5, 7/10 
      //strswap(a, b);
      int value = strcmp(a, c);
      if (value == -1) {
        strswap(b, c);// - 코드 중복 없도록 미리 앞으로 안 뺸 이유: 케이스에 의해 최종 바꿔줘야하는 것에 따라 더 효율적이게 될 수도 있다고 생각했음. 케이스에 의해 최종 바꿔줘야하는 것들을 보니 효율은 차이 없음
      }
      else if (value = 1) {
        strswap(b, c);
        strswap(a, b);
      }
    }
    printf("%s %s %s", a, b, c);
  
    return 0;
  }
  ```

### Ch 13
-  너무 쉬워서 일단 보류
  + vs 찾아보면 input_data(&a, &b); 포함된 거 있을 수도 있음
    
### ch 17
- ch 17-2 성적 처리 프로그램[도전 실전 예제]
  ```C
  #define _CRT_SECURE_NO_WARNINGS
  #include <stdio.h>
  #include <stdlib.h> 
  
  typedef struct {
  	int number;
  	char name[20];
  	int grades[3];
  	int total;
  	double avg;
  	char alph;
  } Student;
  
  int main (void){
    Student people[5]; // - (a) 앗 하고 수정했으면 코드 다 훑기!!!!!
  	int max_ids[5] = { 0,1,2,3,4 }; // - 아직 각각에 대한 구조 객체를 만들지도 않았어도, 이 변수에 넣을 초기값이 어차피 객체의 번째 인덱스라서 초기값으로 할 거 미리 알 수 있음
  	for (int i = 0; i < 5; i++) {
  		printf("학번 : ");
  		scanf("%d", & (people[i].number ) );
  		printf("이름 : "); // - scanf 입력할 때 막판에 엔터 하나 cmd에 입력시키게됨. 그니까 굳이 \n 안 넣어도 됨.
  		scanf("%s", &( people[i].name));
  		printf("국어, 영어, 수학 점수 : ");
  		scanf("%d%d%d", &(people[i].grades[0]), &(people[i].grades[1]),&( people[i].grades[2]));
  
  		people[i].total = people[i].grades[0] + people[i].grades[1] + people[i].grades[2];
  		people[i].avg = people[i].total / (double)3;
      people[i].alph = (people[i].avg >= 90.0) ? 'A' :
                 (people[i].avg >= 80.0) ? 'B' :
                 (people[i].avg >= 70.0) ? 'C' : 'F';
  		
  		// i vs i-1 인데 이걸 연달아도 가능하게 한칸 씩 땡겨 나갈꺼므로((~~연결리스트 포인터마냥)) j vs j-1
  		for (int j = i; j-1 >= 0; j --) {// 이전 것들과 비교하면서 가장 앞자리(max)로 갈 수 있는지. [0<~i-1]까지와 비교해보면 됨
  			if (people[  max_ids[j-1]  ].total < people[ i].total) { // i대신 max_ids[j]도 됨. j 는 안됨 . 다음 앞에 것도 또 거슬러 올라가나 검사하는 상황에서, j는 이미 감소돼있음. 새로운 놈이 최대값 순서 배열에서 어디에 위치할지 비교하는 건데 새로운 놈 말고 다른 놈으로 바뀌게 돼버림.  max_ids[ j] 가 되는 이유는, 거슬러 올라온 상황에서 max_ids[j]의 j도 이미 감소했지만 저 요소값이 새로운 놈이고 이미 swap돼어온 것이기 때문임. / 아예 i는 새로운 놈 고정임. 대신 아래의 인덱스 swap에서는 i 주의해라 
  				//swap j, j-1. 여기부턴 max_ids의 값을 지정해주는 거라, max_ids[j]대신 i를 쓸 일 없음.
  				int temp = max_ids[j - 1];
  				max_ids[j-1] = max_ids[j]; // for 돌면서 여러 단계 거슬러 올라갈 수도 있음.// max_ids가 가지고 있는 인덱스 값을 바꾸는 거니까 우변 j절대 안되지! swap의미도 알텐데 왜 그랬대(if문의 주석과 비슷한 맥락으로 그런듯). 여길 그렇게 했을 때도 그정도나 정답에 근접할 수있다니. 약간만 값틀려도 핵심 알고리즘 틀린 부분 있을 수 있는 거 감안해라.(물론 이어서 거슬러 올라가는게 이 케이스에선 흔하지 않아서 그랬을듯)
          // - > for에 따라 그거의 값이 어떻게 바뀌는지 검산으로 체크하기? (그럴 시간이 있으련지.. 결과 확인 및 디버깅이 차라리 빠르련지..)
          
          max_ids[j] = temp;
  			}
        // 효율을 위해 첫 for 내부에서 돌리는 중. & 새로운 놈이 더 작으면 더 이상 비교할 필요 없음. 
  			else { // 비교해서 더 작아도 처음이면 저장은 해야지. -> 어차피 비교 대상 개수는 i,j로 범위 잡았으니(=범위 벗어나는 부분 비교는 자동으로 안할테니) 초기값을 각 인덱스로해줄 수 있음.
  				break;
  			}
  		}
  	}
  	// 21034 가 떠야하는데  
  	// 1204-1뜨네 // 기호 -아님 -1 정수임. %d임.
  	// 12034 // 맨 앞 까지 검사를 못하나. 
  	// 11034
  	// printf("%d%d%d%d%d-", max_ids[0],max_ids[1],max_ids[2],max_ids[3],max_ids[4]);
  
  	printf("# 정렬 전 데이터...\n"); // # 앞에 역슬래시 하나 안 하나 같네
  	for (int i = 0; i < 5; i++) {
  		printf("%6d %6s%6d%6d%6d", people[i].number, people[i].name, people[i].grades[0], people[i].grades[1], people[i].grades[2]);
  		printf("%6d%6.1lf%6c\n", people[i].total, people[i].avg, people[i].alph);
  	}
    
    // total max 순서로 출력하기
  	// 완전한 덩어리 swap을 기대했을 수도 있긴 하겠는데 난 인덱스를 기억하겠다.(인덱스를 swap) ////m_x 예전에 만든 3개 비교하는 걸 연속해서? 
  	// sort 알고리즘 : 최단 sort알고리즘으로 풀진 않고 직접 먼저 생각나는 방법으로 함 
  	// 멍 때리면 안댕!(이사짐 다 치우곤 더 괜찮을듯. 공부와 기타 등등을 위해 적당히씩 푸는 중 ㅎㅋ 틈새시간에 하기..ㅎㅋ) 
  	// m1. max찾, 그 다음 max찾. 
  	// - strcmp는 어차피 숫자 바로 비교할 수 있어서 의미없
  
  	// M2. 9, 7 ,3 <<--올라갈 수 있는 만큼 거슬러 올라가기->,x,x,x
  	// 효율을 위해 저장하면서 최대값 업데이트 -> 위 for문 안에 작성.
  
  	printf("# 정렬 후 데이터...\n"); 
  	for (int i = 0; i < 5; i++) {
  		printf("%6d %6s%6d%6d%6d", people[max_ids[i]].number, people[max_ids[i]].name, people[max_ids[i]].grades[0], people[max_ids[i]].grades[1], people[max_ids[i]].grades[2]);
  		printf("%6d%6.1lf%6c\n", people[max_ids[i]].total, people[max_ids[i]].avg, people[max_ids[i]].alph);
  	}
    return 0;
  }
  ```

### ch 18
- 18-2 단어 검출 프로그램[도전 실전 예제]
  + ```C
    // - 파일 읽고 쓰기라, VS의 프로젝트 폴더에 txt파일 2개[1] 만들어둠. w는 자동으로 만들어져서 괜찮음.
    #define _CRT_SECURE_NO_WARNINGS
    #include <stdio.h>
    #include <stdlib.h> 
    #include <string.h>
    int main() {
    	// 정렬해서 빠르게 넘어가거나 알파벳을 행으로 해서 빠르게 찾을까 했는데, 전자는 이미 이전 문제에서 구현했었고 등록 단어수 최대 10개라 그냥 적당히 함. 입출력용 문제풀이기에
    	FILE* fpr1,* fpr2,* fpw;
    	char list[10][21];
    	char target[21];
    	int res;
    	int exist = 0;
    	fpr1 = fopen("a.txt", "r");
    	fpr2 = fopen("b.txt", "r");
    	fpw = fopen("c.txt", "w");
    
    	//~ 9개 입력해보기
    	for(int i=0; i<10; i++){
    		// 한줄 엔터 미포함
    		res=fscanf(fpr1, "%s", list[i]); // 엔터 어케 먹을지
    		if (res == EOF) break;
    		//printf("%s%d\n", list[i],i);
    	}
    
    	res = fscanf(fpr2, "%s", target);
    	while (res != EOF) {
    
    		// target ="lion"
    		exist = 0;
    		for (int i = 0; i < 10; i++) {
    			if (strcmp(list[i], target) == 0) {
    				exist = 1;
    				break;
    			}
    		}
    		if (exist == 0) { // 새로운 거면 c에 쓰기
    			fprintf(fpw, "%s\n", target);
    		}
    		res = fscanf(fpr2, "%s", target);
    	}
    	fclose(fpr1);
    	fclose(fpr2);
    	fclose(fpw);
    	return 0;
    }
    /* -[1] 파일 준비
    - a.txt
    dog
    tiger
    horse
    monkey
    lion
    koala
    giraffe
    owl
    
    - b.txt
    lion
    elephant
    pear
    dog
    tiger
    apple
    kangaroo
    orange
    bear
    owl
    */
    ```
